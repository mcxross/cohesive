package com.mcxross.cohesive.cps.processor

import java.io.BufferedWriter
import java.io.FileNotFoundException
import java.io.IOException
import java.nio.file.NoSuchFileException
import javax.annotation.processing.FilerException
import javax.tools.FileObject
import javax.tools.StandardLocation

/**
 * Stores [com.mcxross.cohesive.cps.Extension]s in `META-INF/services`.
 *//*

class ServiceProviderExtensionStorage(processor: ExtensionProcessor) :
    ExtensionStorage(processor) {
    override fun read(): Map<String?, Set<String>> {
        val extensions: MutableMap<String, Set<String>> = HashMap()
        for (extensionPoint: String in processor.getExtensions().keys) {
            try {
                val file: FileObject = getFiler().getResource(
                    StandardLocation.CLASS_OUTPUT, "",
                    EXTENSIONS_RESOURCE
                            + "/" + extensionPoint
                )
                val entries: Set<String> = HashSet()
                ExtensionStorage.read(file.openReader(true), entries)
                extensions[extensionPoint] = entries
            } catch (e: FileNotFoundException) {
                // doesn't exist, ignore
            } catch (e: NoSuchFileException) {
            } catch (e: FilerException) {
                // re-opening the file for reading or after writing is ignorable
            } catch (e: IOException) {
                error((e.message)!!)
            }
        }
        return extensions
    }

    override fun write(extensions: Map<String?, Set<String?>?>?) {
        for (entry: Map.Entry<String, Set<String>> in extensions.entries) {
            val extensionPoint = entry.key
            try {
                val file: FileObject = getFiler().createResource(
                    StandardLocation.CLASS_OUTPUT, "", (EXTENSIONS_RESOURCE
                            + "/" + extensionPoint)
                )
                BufferedWriter(file.openWriter()).use { writer ->
                    // write header
                    writer.write("# Generated by PF4J") // write header
                    writer.newLine()
                    // write extensions
                    for (extension: String in entry.value) {
                        writer.write(extension)
                        if (!isExtensionOld(extensionPoint, extension)) {
                            writer.write(" # pf4j extension")
                        }
                        writer.newLine()
                    }
                }
            } catch (e: FileNotFoundException) {
                // it's the first time, create the file
            } catch (e: FilerException) {
                // re-opening the file for reading or after writing is ignorable
            } catch (e: IOException) {
                error(e.toString())
            }
        }
    }

    private fun isExtensionOld(extensionPoint: String, extension: String): Boolean {
        return (processor.getOldExtensions().containsKey(extensionPoint)
                && processor.getOldExtensions().get(extensionPoint).contains(extension))
    }

    companion object {
        val EXTENSIONS_RESOURCE = "META-INF/services"
    }
}*/
