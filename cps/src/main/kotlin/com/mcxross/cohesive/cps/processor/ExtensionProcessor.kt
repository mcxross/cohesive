package com.mcxross.cohesive.cps.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import com.mcxross.cohesive.cps.Extension
import java.io.OutputStream
import kotlin.reflect.KClass

class ExtensionProcessor(private val environment: SymbolProcessorEnvironment) : SymbolProcessor {

    private fun Resolver.findAnnotations(kClass: KClass<*>) = getSymbolsWithAnnotation(kClass.qualifiedName.toString())
        .filterIsInstance<KSClassDeclaration>()

    operator fun OutputStream.plusAssign(str: String) {
        this.write(str.toByteArray())
    }

    override fun process(resolver: Resolver): List<KSAnnotated> {
        info("Init ${ExtensionProcessor::class.simpleName}")

        val symbols = resolver
            .findAnnotations(Extension::class)

        if (!symbols.iterator().hasNext()) return emptyList()

        val file: OutputStream = getCodeGenerator().createNewFile(
            dependencies = Dependencies(false, *resolver.getAllFiles().toList().toTypedArray()),
            packageName = "com.mcxross.cohesive.r",
            fileName = "Extensions"
        )
        file += "//Generated by Cohesive Plugin System Processor\n"
        file += "//Don't edit\n\n"
        file += "package com.mcxross.cohesive.r\n"

        symbols.forEach { it.accept(Visitor(file = file, ep = this), Unit) }

        file.close()

        return symbols.filterNot { it.validate() }.toList()
    }

    private fun getCodeGenerator(): CodeGenerator {
        return environment.codeGenerator
    }

    private fun getLogger(): KSPLogger {
        return environment.logger
    }

    fun info(message: String, symbol: KSNode? = null) {
        getLogger().info(message = message, symbol = symbol)
    }

     fun error(message: String, symbol: KSNode? = null) {
        getLogger().error(message = message, symbol = symbol)
    }
}